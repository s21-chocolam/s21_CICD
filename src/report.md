## Part 1. Настройка gitlab-runner

- Подними виртуальную машину Ubuntu Server 22.04 LTS

![](pict/part1/cicd.png)

- Скачай и установи на виртуальную машину gitlab-runner

![](pict/part1/runner.png)

- Запусти gitlab-runner и зарегистрируй его для использования в текущем проекте (DO6_CICD)

1. берем URL и токен со страницы проекта

![](pict/part1/token.png)

2. регистрируем gitlab-runner, вводим:

- URL-адрес GitLab
- токен
- название раннера
- теги для заданий (через запятую)
- тип оболочки

![](pict/part1/register.png)

## Part 2. Сборка

#### Напиши этап для CI по сборке приложений из проекта C2_SimpleBashUtils.

1. В корне репозитория создать файл .gitlab-ci.yml

```ssh
touch .gitlab-ci.yml
```

2. В файле gitlab-ci.yml добавь этап запуска сборки через мейк файл из проекта C2. Файлы, полученные после сборки (артефакты), сохрани в произвольную директорию со сроком хранения 30 дней

![](pict/part2/yml.png)

3. после пуша появилась ошибка:

![](pict/part2/failed.png)

- Эта ошибка может возникать из-за проблем при загрузке профиля оболочки (shell) в GitLab Runner, в профиле оболочки есть команды или настройки, которые приводят к ошибке при выполнении GitLab CI задачи. Для исправления ошибки нужно закомментировать строки в `/home/gitlab-runner/.bash_logout`

![](pict/part2/comment.png)

- после исправлений стадия фейлилась. чтобы этого не было - нужно установить gcc и make на машину, после этого стадия завершается успешно

![](pict/part2/new.png)

## Part 3. Тест кодстайла

#### Напиши этап для CI, который запускает скрипт кодстайла (clang-format):

1) пишем скрипт, который фейлит пайплайн если `clang-format` выводит ошибки:

![](pict/part3/yml.png)

- устанавливаем на машину `clang-format` и пушим в гитлаб, видим, что стадия завершается успешно

![](pict/part3/pass.png)

- делаем ошибку в коде, чтобы `clang` начал ругаться

![](pict/part3/clang.png)

- проверяем, что стадия зафейлилась

![](pict/part3/fail.png)

## Part 4. Интеграционные тесты

#### Напиши этап для CI, который запускает твои интеграционные тесты из того же проекта

1) пишем скрипт, который фейлит пайплайн если в тестах есть ошибки:

![](pict/part4/yml.png)

2) пушим, проверяем с успешными тестами:

![](pict/part4/correcttest.png)

3) вручную фейлим один из тестов

![](pict/part4/failed.png)

4) проверяем с зафейленным тестом:

![](pict/part4/errortest.png)

#### Запусти этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно

1) делаем стилевую ошибку в `cat.c`, чтобы предыдущая стадия фейлилась и добавляем правило, которое запускает нашу стадию только если предыдущие стадии прошли успешно

![](pict/part4/rules.png)

2) проверяем наш пайплайн

![](pict/part4/errorwithrules.png)

3) убираем ошибки из `cat.c` и снова проверяем пайплайн, что все проходит без ошибок

![](pict/part4/errorwithrules.png)

## Part 5. Этап деплоя

#### Подними вторую виртуальную машину Ubuntu Server 22.04 LTS.

![](pict/part5/ubuntu2.png)

- настраиваем внутреннюю сеть

![](pict/part5/cicdnet.png) ![](pict/part5/cicd2net.png)

- проверяем соединение между машинами

![](pict/part5/cicdping.png) ![](pict/part5/cicd2ping.png)

- для удобства подключаюсь к каждой машине через VSCode и генерирую ssh-ключ на второй машине (на первой он уже у меня есть)

![](pict/part5/ssh-keygen.png)

- добавляем ключ второй машины в гитлаб

#### Напиши этап для CD, который «разворачивает» проект на другой виртуальной машине

- дописываем этап деплоя на первой машине, который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию `/usr/local/bin` второй виртуальной машины

![](pict/part5/yml.png)

- переходим в пользователя gitlab-runner с помощью `sudo su gitlab-runner`

![](pict/part5/sugit.png)

- генерируем ssh-ключ

![](pict/part5/sshgit.png)

- пробрасываем ключ на вторую машину (`ssh-copy-id chocolam@192.10.10.2`)

![](pict/part5/ssh-copy.png)

- проверить можно на второй машине с помощью команды `cat ~/.ssh/authorized_keys`

![](pict/part5/autkeys.png)

- возвращаемся на своего пользователя и даём пользователю gitlab-runner больше прав (`sudo usermod -aG sudo gitlab-runner`)

![](pict/part5/usermod.png)

- на второй машине даём права к директории `/usr/local/bin`

![](pict/part5/chmod.png)

#### Запусти этот этап вручную при условии, что все предыдущие этапы прошли успешно

- блок кода для запука этапа вручную

![](pict/part5/manual.png)

- проверяем в гитлабе, что этап нужно запускать вручную

![](pict/part5/manualcheck.png)

- после некоторой отладки скрипта деплой прошел успешно

![](pict/part5/success.png)

#### Проверяем, что этап фейлится в случае ошибки

- немного меняем скрипт чтобы "копировался" неправильный файл (перед этим удаляем артефакты со второй машины)

![](pict/part5/test.png)

- пушим, ждем пока пройдут 3 этапа, запускаем этап деплоя, проверяем

![](pict/part5/error.png)

- возвращаем всё в исходное состояние

## Part 6. Дополнительно. Уведомления

#### Настрой уведомления о успешном/неуспешном выполнении пайплайна через бота с именем «[твой nickname] DO6 CI/CD» в Telegram

- находим BotFather в телеграме, создаем нового бота

![](pict/part6/createbot.png)

- ищем бота getmyid_bot и пишем ему `/start` для получения ID

![](pict/part6/getid.png)

- добавляем .notify: &notify в файл `.gitlab-ci.yml`, в нем определим набор команд для уведомлений, которые будут использованы во всех этапах

1) подключаем переменные c ID и токеном
2) прописываем сообщение для бота, исходя из результата предыдущего этапа
3) отправляем сообщение боту через `curl` и `ssh`

![](pict/part6/notify.png)

- в `after_script` каждого этапа прописываем вызов `notify`

![](pict/part6/after.png)

- проверяем пайплайн

![](pict/part6/pipe.png)

- проверяем телеграм-бота

![](pict/part6/bot.png)